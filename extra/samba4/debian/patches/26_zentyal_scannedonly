Index: samba4-4.1.0rc4/source3/modules/vfs_scannedonly.c
===================================================================
--- samba4-4.1.0rc4.orig/source3/modules/vfs_scannedonly.c	2013-06-13 11:21:02.000000000 +0200
+++ samba4-4.1.0rc4/source3/modules/vfs_scannedonly.c	2013-10-18 17:25:21.816211908 +0200
@@ -50,16 +50,24 @@
 #include "includes.h"
 #include "smbd/smbd.h"
 #include "system/filesys.h"
+#include "librpc/gen_ndr/auth.h"
 
 #include "config.h"
 
-#define SENDBUFFERSIZE 1450
-
 #ifndef       SUN_LEN
 #define       SUN_LEN(sunp)   ((size_t)((struct sockaddr_un *)0)->sun_path \
 				+ strlen((sunp)->sun_path))
 #endif
 
+#define STRUCTSCANO(var) ((struct Tscannedonly *)var)
+#define SCANNEDONLY_DEBUG 4
+
+struct scannedonly_DIR {
+	const char *base;
+	int recheck_tries_done; /* if 0 the directory listing has not yet
+	been checked for files that need to be scanned. */
+	DIR *DIR;
+};
 
 struct Tscannedonly {
 	int socket;
@@ -81,23 +89,13 @@
 	const char *p_scanned; /* prefix for scanned files */
 	const char *p_virus; /* prefix for virus containing files */
 	const char *p_failed; /* prefix for failed to scan files */
-	char gsendbuffer[SENDBUFFERSIZE + 1];
+	struct scannedonly_DIR *dir_data;
 };
 
-#define STRUCTSCANO(var) ((struct Tscannedonly *)var)
-
-struct scannedonly_DIR {
-	char *base;
-	int recheck_tries_done; /* if 0 the directory listing has not yet
-	been checked for files that need to be scanned. */
-	DIR *DIR;
-};
-#define SCANNEDONLY_DEBUG 9
 /*********************/
 /* utility functions */
 /*********************/
-
-static char *real_path_from_notify_path(TALLOC_CTX *ctx,
+static char *real_path_from_notify_path(TALLOC_CTX *mem_ctx,
 					struct Tscannedonly *so,
 					const char *path)
 {
@@ -120,219 +118,225 @@
 		return NULL;
 	}
 
-	return talloc_strndup(ctx,path,
-			      pathlen + len - so->scanning_message_len);
+	return talloc_strndup(mem_ctx, path,
+		pathlen + len - so->scanning_message_len);
 }
 
-static char *cachefile_name(TALLOC_CTX *ctx,
+static char *cachefile_name(TALLOC_CTX *mem_ctx,
 			    const char *shortname,
 			    const char *base,
 			    const char *p_scanned)
 {
-	return talloc_asprintf(ctx, "%s%s%s", base, p_scanned, shortname);
+	return talloc_asprintf(mem_ctx, "%s%s%s", base, p_scanned, shortname);
 }
 
-static char *name_w_ending_slash(TALLOC_CTX *ctx, const char *name)
+static char *name_w_ending_slash(TALLOC_CTX *mem_ctx, const char *name)
 {
 	int len = strlen(name);
 	if (name[len - 1] == '/') {
-		return talloc_strdup(ctx,name);
+		return talloc_strdup(mem_ctx, name);
 	} else {
-		return talloc_asprintf(ctx, "%s/", name);
+		return talloc_asprintf(mem_ctx, "%s/", name);
 	}
 }
 
-static char *cachefile_name_f_fullpath(TALLOC_CTX *ctx,
+static char *cachefile_name_f_fullpath(TALLOC_CTX *mem_ctx,
 				       const char *fullpath,
 				       const char *p_scanned)
 {
+	TALLOC_CTX *frame = talloc_stackframe();
 	const char *base;
 	char *tmp, *cachefile;
 	const char *shortname;
 	tmp = strrchr(fullpath, '/');
 	if (tmp) {
-		base = talloc_strndup(ctx, fullpath, (tmp - fullpath) + 1);
-		shortname = tmp + 1;
+		base = talloc_strndup(talloc_tos(), fullpath, (tmp - fullpath) + 1);
+		shortname = talloc_strdup(talloc_tos(), tmp + 1);
 	} else {
-		base = "";
-		shortname = (const char *)fullpath;
+		base = talloc_strdup(talloc_tos(), "");
+		shortname = talloc_strdup(talloc_tos(), fullpath);
 	}
-	cachefile = cachefile_name(ctx, shortname, base, p_scanned);
-	DEBUG(SCANNEDONLY_DEBUG,
-	      ("cachefile_name_f_fullpath cachefile=%s\n", cachefile));
+
+	cachefile = cachefile_name(mem_ctx, shortname, base, p_scanned);
+	talloc_free(frame);
+
+	DEBUG(SCANNEDONLY_DEBUG, ("%s: cachefile=%s\n", __func__, cachefile));
 	return cachefile;
 }
 
-static char *construct_full_path(TALLOC_CTX *ctx, vfs_handle_struct * handle,
+static const char *construct_full_path(TALLOC_CTX *mem_ctx, vfs_handle_struct * handle,
 				 const char *somepath, bool ending_slash)
 {
-	const char *tmp;
+	const char *tmp, *retval;
 
 	if (!somepath) {
 		return NULL;
 	}
 	if (somepath[0] == '/') {
 		if (ending_slash) {
-			return name_w_ending_slash(ctx,somepath);
+			return name_w_ending_slash(mem_ctx, somepath);
 		}
-		return talloc_strdup(ctx,somepath);
+		return talloc_strdup(mem_ctx, somepath);
 	}
+
 	tmp = somepath;
 	if (tmp[0]=='.'&&tmp[1]=='/') {
 		tmp+=2;
 	}
+
 	/* vfs_GetWd() seems to return a path with a slash */
 	if (ending_slash) {
-		return talloc_asprintf(ctx, "%s/%s/",
-				       vfs_GetWd(ctx, handle->conn),tmp);
+		TALLOC_CTX *frame = talloc_stackframe();
+		char *aux = vfs_GetWd(talloc_tos(), handle->conn);
+		retval = talloc_asprintf(mem_ctx, "%s/%s/", aux ,tmp);
+		talloc_free(frame);
+		return retval;
 	}
-	return talloc_asprintf(ctx, "%s/%s",
-			       vfs_GetWd(ctx, handle->conn),tmp);
+
+	TALLOC_CTX *frame = talloc_stackframe();
+	char *aux = vfs_GetWd(talloc_tos(), handle->conn);
+	retval = talloc_asprintf(mem_ctx, "%s/%s", aux, tmp);
+	talloc_free(frame);
+	return retval;
 }
 
-static int connect_to_scanner(vfs_handle_struct * handle)
+static int scannedonly_connect_to_scanner(vfs_handle_struct * handle)
 {
 	struct Tscannedonly *so = (struct Tscannedonly *)handle->data;
 
 	if (so->domain_socket) {
 		struct sockaddr_un saun;
-		DEBUG(SCANNEDONLY_DEBUG, ("socket=%s\n", so->socketname));
+		DEBUG(SCANNEDONLY_DEBUG, ("%s: socket=%s\n", __func__,
+			so->socketname));
 		if ((so->socket = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) {
-			DEBUG(2, ("failed to create socket %s\n",
-				  so->socketname));
-			return -1;
+			DEBUG(0, ("%s: failed to create socket %s: (%d %s)\n",
+				  __func__, so->socketname, errno, strerror(errno)));
+			return errno;
 		}
 		saun.sun_family = AF_UNIX;
 		strncpy(saun.sun_path, so->socketname,
 			sizeof(saun.sun_path) - 1);
 		if (connect(so->socket, (struct sockaddr *)(void *)&saun,
 			    SUN_LEN(&saun)) < 0) {
-			DEBUG(2, ("failed to connect to socket %s\n",
-				  so->socketname));
-			return -1;
+			DEBUG(0, ("%s: failed to connect to socket %s (%d %s)\n",
+				  __func__, so->socketname, errno, strerror(errno)));
+			return errno;
 		}
-		DEBUG(SCANNEDONLY_DEBUG,("bound %s to socket %d\n",
-					 saun.sun_path, so->socket));
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: bound %s to socket %d\n", __func__,
+				saun.sun_path, so->socket));
 
 	} else {
 		so->socket = open_udp_socket(so->scanhost, so->portnum);
 		if (so->socket < 0) {
-			DEBUG(2,("failed to open UDP socket to %s:%d\n",
-				 so->scanhost,so->portnum));
+			DEBUG(0, ("%s: failed to open UDP socket to %s:%d\n",
+				 __func__, so->scanhost,so->portnum));
 			return -1;
 		}
 	}
 
-	{/* increasing the socket buffer is done because we have large bursts
-	    of UDP packets or DGRAM's on a domain socket whenever we hit a
-	    large directory with lots of unscanned files. */
+	{
+		/* Increasing the socket buffer is done because we have large
+		 * bursts of UDP packets or DGRAM's on a domain socket whenever
+		 * we hit a large directory with lots of unscanned files. */
 		int sndsize;
 		socklen_t size = sizeof(int);
-		getsockopt(so->socket, SOL_SOCKET, SO_RCVBUF,
-			   (char *)&sndsize, &size);
-		DEBUG(SCANNEDONLY_DEBUG, ("current socket buffer size=%d\n",
-					  sndsize));
+		getsockopt(so->socket, SOL_SOCKET, SO_RCVBUF, (char *)&sndsize,
+			 &size);
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: current socket buffer size=%d\n", __func__,
+				sndsize));
 		sndsize = 262144;
 		if (setsockopt(so->socket, SOL_SOCKET, SO_RCVBUF,
 			       (char *)&sndsize,
 			       (int)sizeof(sndsize)) != 0) {
 			DEBUG(SCANNEDONLY_DEBUG,
-			      ("error setting socket buffer %s (%d)\n",
-			       strerror(errno), errno));
+			      ("%s: error setting socket buffer %s (%d)\n",
+					__func__, strerror(errno), errno));
 		}
 	}
 	set_blocking(so->socket, false);
 	return 0;
 }
 
-static void flush_sendbuffer(vfs_handle_struct * handle)
+static bool scannedonly_notify_scanner(vfs_handle_struct * handle, const char *scanfile)
 {
+	const char *tmp;
+	char *sendbuf, *prefix;
+	int tmplen;
+	int ret;
+	int offset = 0;
 	struct Tscannedonly *so = (struct Tscannedonly *)handle->data;
-	int ret, len, loop = 10;
-	if (so->gsendbuffer[0] == '\0') {
-		return;
+	TALLOC_CTX *frame = talloc_stackframe();
+	int try = 3;
+
+	if (scanfile[0] != '/') {
+		tmp = construct_full_path(talloc_tos(), handle, scanfile, false);
+	} else {
+		tmp = talloc_strdup(talloc_tos(), scanfile);
 	}
+	if (!tmp) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return false;
+	}
+	prefix = talloc_sub_advanced(talloc_tos(),
+			lp_servicename(talloc_tos(), SNUM(handle->conn)),
+			handle->conn->session_info->unix_info->unix_name,
+			handle->conn->connectpath,
+			handle->conn->session_info->unix_token->gid,
+			handle->conn->session_info->unix_info->sanitized_username,
+			handle->conn->session_info->info->domain_name,
+			"%u\x1E%I");
+	if (!prefix) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return false;
+	}
+	sendbuf = talloc_asprintf(talloc_tos(), "%s\x1E%s\n", prefix, tmp);
+	if (!sendbuf) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return false;
+	}
+	tmplen = strlen(sendbuf);
 
 	do {
-		loop--;
-		len = strlen(so->gsendbuffer);
-		ret = send(so->socket, so->gsendbuffer, len, 0);
-		if (ret == len) {
-			so->gsendbuffer[0] = '\0';
+		int bytes_to_send = tmplen - offset;
+		ret = send(so->socket, sendbuf + offset, bytes_to_send, 0);
+		if (ret == bytes_to_send) {
+			/* All sent */
 			break;
-		}
-		if (ret == -1) {
-			DEBUG(3,("scannedonly flush_sendbuffer: "
-				 "error sending on socket %d to scanner:"
-				 " %s (%d)\n",
-				 so->socket, strerror(errno), errno));
-			if (errno == ECONNREFUSED || errno == ENOTCONN
-			    || errno == ECONNRESET) {
-				if (connect_to_scanner(handle) == -1)
-					break;	/* connecting fails, abort */
-				/* try again */
-			} else if (errno != EINTR) {
-				/* on EINTR we just try again, all remaining
-				   other errors we log the error
-				   and try again ONCE */
-				loop = 1;
-				DEBUG(3,("scannedonly flush_sendbuffer: "
-					 "error sending data to scanner: %s "
-					 "(%d)\n", strerror(errno), errno));
-			}
-		} else {
-			/* --> partial write: Resend all filenames that were
-			   not or not completely written. a partial filename
-			   written means the filename will not arrive correctly,
-			   so resend it completely */
-			int pos = 0;
-			while (pos < len) {
-				char *tmp = strchr(so->gsendbuffer+pos, '\n');
-				if (tmp && tmp - so->gsendbuffer < ret)
-					pos = tmp - so->gsendbuffer + 1;
-				else
+		} else if (ret == -1) {
+			/* Error sending */
+			DEBUG(0, ("%s: error sending on socket %d to scanner:"
+				" %s (%d)\n", __func__, so->socket,
+				strerror(errno), errno));
+			if (errno == ECONNREFUSED ||errno == ENOTCONN
+				|| errno == ECONNRESET)
+			{
+				if (scannedonly_connect_to_scanner(handle) == -1) {
+					/* connecting fails, abort */
 					break;
+				}
 			}
-			memmove(so->gsendbuffer, so->gsendbuffer + pos,
-				SENDBUFFERSIZE - ret);
-			/* now try again */
+			/* Try again */
+			try--;
+			continue;
 		}
-	} while (loop > 0);
+		/* partial write, can be 0 */
+		try--;
+		offset += ret;
+	} while ((offset < tmplen) && (try >= 0));
 
-	if (so->gsendbuffer[0] != '\0') {
-		DEBUG(2,
-		      ("scannedonly flush_sendbuffer: "
-		       "failed to send files to AV scanner, "
-		       "discarding files."));
-		so->gsendbuffer[0] = '\0';
-	}
-}
-
-static void notify_scanner(vfs_handle_struct * handle, const char *scanfile)
-{
-	const char *tmp;
-	int tmplen, gsendlen;
-	struct Tscannedonly *so = (struct Tscannedonly *)handle->data;
-	TALLOC_CTX *ctx=talloc_tos();
-	if (scanfile[0] != '/') {
-		tmp = construct_full_path(ctx,handle, scanfile, false);
-	} else {
-		tmp = (const char *)scanfile;
-	}
-	tmplen = strlen(tmp);
-	gsendlen = strlen(so->gsendbuffer);
-	DEBUG(SCANNEDONLY_DEBUG,
-	      ("scannedonly notify_scanner: tmp=%s, tmplen=%d, gsendlen=%d\n",
-	       tmp, tmplen, gsendlen));
-	if (gsendlen + tmplen >= SENDBUFFERSIZE) {
-		flush_sendbuffer(handle);
-	}
-	/* FIXME ! Truncate checks... JRA. */
-	(void)strlcat(so->gsendbuffer, tmp, SENDBUFFERSIZE + 1);
-	(void)strlcat(so->gsendbuffer, "\n", SENDBUFFERSIZE + 1);
+	talloc_free(frame);
+	return ((offset == tmplen) && (try > 0));
 }
 
-static bool is_scannedonly_file(struct Tscannedonly *so, const char *shortname)
+static bool scannedonly_is_scannedonly_file(struct Tscannedonly *so, const char *shortname)
 {
 	if (shortname[0]!='.') {
 		return false;
@@ -355,21 +359,21 @@
 }
 
 /*
-vfs_handle_struct *handle the scannedonly handle
-scannedonly_DIR * sDIR the scannedonly struct if called from _readdir()
-or NULL
-fullpath is a full path starting from / or a relative path to the
-current working directory
-shortname is the filename without directory components
-basename, is the directory without file name component
-allow_nonexistent return TRUE if stat() on the requested file fails
-recheck_time, the time in milliseconds to wait for the daemon to
-create a .scanned file
-recheck_tries, the number of tries to wait
-recheck_size, size in Kb of files that should not be waited for
-loop : boolean if we should try to loop over all files in the directory
-and send a notify to the scanner for all files that need scanning
-*/
+ * vfs_handle_struct	- handle the scannedonly handle
+ * scannedonly_DIR 	- sDIR the scannedonly struct if called from _readdir()
+ *			  or NULL
+ * smb_filename		- full path starting from / or a relative path to the
+ * 			  current working directory
+ * shortname		- the filename without directory components
+ * basename		- the directory without file name component
+ * allow_nonexistent 	- return TRUE if stat() on the requested file fails
+ * recheck_time		- the time in milliseconds to wait for the daemon to
+ *			  create a .scanned file
+ * recheck_tries 	- the number of tries to wait
+ * recheck_size		- size in Kb of files that should not be waited for
+ * loop 		- boolean if we should try to loop over all files in the directory
+ * 			  and send a notify to the scanner for all files that need scanning
+ */
 static bool scannedonly_allow_access(vfs_handle_struct * handle,
 				     struct scannedonly_DIR *sDIR,
 				     struct smb_filename *smb_fname,
@@ -379,70 +383,104 @@
 				     int recheck_time, int recheck_tries,
 				     int recheck_size, int loop)
 {
-	struct smb_filename *cache_smb_fname;
-	TALLOC_CTX *ctx=talloc_tos();
-	char *cachefile;
+	struct smb_filename *cache_smb_fname = NULL;
+	char *cachefile = NULL;
 	int retval = -1;
+	TALLOC_CTX *frame = talloc_stackframe();
+
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("smb_fname->base_name=%s, shortname=%s, base_name=%s\n"
-	       ,smb_fname->base_name,shortname,base_name));
+	      ("%s: smb_fname->base_name=%s, shortname=%s, base_name=%s\n",
+			__func__, smb_fname->base_name, shortname, base_name));
 
 	if (ISDOT(shortname) || ISDOTDOT(shortname)) {
+        	DEBUG(SCANNEDONLY_DEBUG,
+			("%s: Is dot or dotdot, returning true\n", __func__));
+		talloc_free(frame);
 		return true;
 	}
-	if (is_scannedonly_file(STRUCTSCANO(handle->data), shortname)) {
+	if (scannedonly_is_scannedonly_file(STRUCTSCANO(handle->data), shortname)) {
 		DEBUG(SCANNEDONLY_DEBUG,
-		      ("scannedonly_allow_access, %s is a scannedonly file, "
-		       "return 0\n", shortname));
+			("%s: %s is a scannedonly file, returning false\n",
+				__func__, shortname));
+		talloc_free(frame);
 		return false;
 	}
-
 	if (!VALID_STAT(smb_fname->st)) {
-		DEBUG(SCANNEDONLY_DEBUG,("stat %s\n",smb_fname->base_name));
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: no valid stat (%s)\n", __func__, smb_fname->base_name));
 		retval = SMB_VFS_NEXT_STAT(handle, smb_fname);
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: stat (%s) returns (%d)\n", __func__, smb_fname->base_name, retval));
 		if (retval != 0) {
-			/* failed to stat this file?!? --> hide it */
-			DEBUG(SCANNEDONLY_DEBUG,("no valid stat, return"
-						 " allow_nonexistent=%d\n",
-						 allow_nonexistent));
+			/* failed to stat this file, hide it */
+			DEBUG(SCANNEDONLY_DEBUG,
+				("%s: no valid stat, return allow_nonexistent=%d\n",
+					__func__, allow_nonexistent));
+			talloc_free(frame);
 			return allow_nonexistent;
 		}
 	}
 	if (!S_ISREG(smb_fname->st.st_ex_mode)) {
 		DEBUG(SCANNEDONLY_DEBUG,
-		      ("%s is not a regular file, ISDIR=%d\n",
-		       smb_fname->base_name,
-		       S_ISDIR(smb_fname->st.st_ex_mode)));
-		return (STRUCTSCANO(handle->data)->
-			show_special_files ||
+			("%s: %s is not a regular file, ISDIR=%d\n",
+				__func__, smb_fname->base_name,
+				S_ISDIR(smb_fname->st.st_ex_mode)));
+		talloc_free(frame);
+		return (STRUCTSCANO(handle->data)->show_special_files ||
 			S_ISDIR(smb_fname->st.st_ex_mode));
 	}
 	if (smb_fname->st.st_ex_size == 0) {
-		DEBUG(SCANNEDONLY_DEBUG,("empty file, return 1\n"));
-		return true;	/* empty files cannot contain viruses ! */
+		/* empty files cannot contain viruses ! */
+		DEBUG(SCANNEDONLY_DEBUG,("%s: empty file, return true\n", __func__));
+		talloc_free(frame);
+		return true;
+	}
+	cachefile = cachefile_name(talloc_tos(), shortname, base_name,
+		STRUCTSCANO(handle->data)->p_scanned);
+	if (!cachefile) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return false;
+	}
+	DEBUG(SCANNEDONLY_DEBUG, ("%s: cache file name is '%s'\n", __func__,
+		cachefile));
+
+	cache_smb_fname = synthetic_smb_fname(talloc_tos(), cachefile, NULL, NULL);
+	if (!cache_smb_fname) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return false;
 	}
-	cachefile = cachefile_name(ctx,
-				   shortname,
-				   base_name,
-				   STRUCTSCANO(handle->data)->p_scanned);
-	cache_smb_fname = synthetic_smb_fname(ctx, cachefile,NULL,NULL);
 	if (!VALID_STAT(cache_smb_fname->st)) {
+		DEBUG(SCANNEDONLY_DEBUG, ("%s: No valid cache file stat (%s)\n",
+			__func__, cache_smb_fname->base_name));
 		retval = SMB_VFS_NEXT_STAT(handle, cache_smb_fname);
+        	DEBUG(SCANNEDONLY_DEBUG, ("%s: cache file stat (%s) returns (%d)\n",
+			__func__, cache_smb_fname->base_name, retval));
 	}
 	if (retval == 0 && VALID_STAT(cache_smb_fname->st)) {
+		DEBUG(SCANNEDONLY_DEBUG, ("%s: Checking timespec_is_newer\n",
+			__func__));
 		if (timespec_is_newer(&smb_fname->st.st_ex_ctime,
 				      &cache_smb_fname->st.st_ex_ctime)) {
-			talloc_free(cache_smb_fname);
+			DEBUG(SCANNEDONLY_DEBUG,
+				("%s: cache file is newer than file, allow access\n",
+					__func__));
+			talloc_free(frame);
 			return true;
 		}
-		/* no cachefile or too old */
-		SMB_VFS_NEXT_UNLINK(handle, cache_smb_fname);
-		retval = -1;
 	}
 
-	notify_scanner(handle, smb_fname->base_name);
+	DEBUG(SCANNEDONLY_DEBUG, ("%s: file must be scanned, notifying scanner\n",
+		__func__));
+	scannedonly_notify_scanner(handle, smb_fname->base_name);
 
 	if (loop && sDIR && sDIR->recheck_tries_done == 0) {
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: this is a directory, notify scanner is some "
+			 "file needs scanning\n", __func__));
 		/* check the rest of the directory and notify the
 		   scanner if some file needs scanning */
 		long offset;
@@ -451,38 +489,58 @@
 		offset = SMB_VFS_NEXT_TELLDIR(handle, sDIR->DIR);
 		dire = SMB_VFS_NEXT_READDIR(handle, sDIR->DIR, NULL);
 		while (dire) {
-			char *fpath2;
-			struct smb_filename *smb_fname2;
-			fpath2 = talloc_asprintf(ctx, "%s%s", base_name,dire->d_name);
+			char *fpath2 = NULL;
+			struct smb_filename *smb_fname2 = NULL;
+			fpath2 = talloc_asprintf(talloc_tos(), "%s%s", base_name,dire->d_name);
+			if (!fpath2) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return false;
+			}
+
 			DEBUG(SCANNEDONLY_DEBUG,
-			      ("scannedonly_allow_access in loop, "
-			       "found %s\n", fpath2));
-			smb_fname2 = synthetic_smb_fname(
-				ctx, fpath2,NULL,NULL);
+			      ("%s: in loop, found %s\n", __func__, fpath2));
+			smb_fname2 = synthetic_smb_fname(talloc_tos(), fpath2, NULL, NULL);
+			if (!smb_fname2) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return false;
+			}
 			scannedonly_allow_access(handle, NULL,
 						 smb_fname2,
 						 dire->d_name,
 						 base_name, 0, 0, 0, 0, 0);
-			talloc_free(fpath2);
-			talloc_free(smb_fname2);
-			dire = SMB_VFS_NEXT_READDIR(handle, sDIR->DIR,NULL);
+			TALLOC_FREE(fpath2);
+			TALLOC_FREE(smb_fname2);
+			dire = SMB_VFS_NEXT_READDIR(handle, sDIR->DIR, NULL);
 		}
 		sDIR->recheck_tries_done = 1;
 		SMB_VFS_NEXT_SEEKDIR(handle, sDIR->DIR, offset);
 	}
-	if (recheck_time > 0
-	    && ((recheck_size > 0
-		 && smb_fname->st.st_ex_size < (1024 * recheck_size))
-		 || (sDIR && sDIR->recheck_tries_done < recheck_tries)
-		)) {
+
+	DEBUG(SCANNEDONLY_DEBUG, ("%s: recheck_time=%d, recheck_size=%d, smb_fname->st.st_ex_size=%d, sDIR=%p, recheck_tries_done=%d, recheck_tries=%d\n",
+		__func__, recheck_time, recheck_size, (int)smb_fname->st.st_ex_size, sDIR, sDIR ? sDIR->recheck_tries_done : 0, recheck_tries));
+
+	/* If it is not a directory and file size > recheck size, return true */
+	if (!sDIR && recheck_size > 0 && smb_fname->st.st_ex_size > (1024 * recheck_size)) {
+		DEBUG(SCANNEDONLY_DEBUG,
+			("%s: file size %d is greather than recheck size %d, return true\n",
+				__func__, (int)smb_fname->st.st_ex_size, (1024 * recheck_size)));
+		talloc_free(frame);
+		return true;
+	}
+
+	if ((recheck_time > 0) || (sDIR && sDIR->recheck_tries_done < recheck_tries)) {
+		DEBUG(SCANNEDONLY_DEBUG, ("%s: waiting cache file\n", __func__));
 		int numloops = sDIR ? sDIR->recheck_tries_done : 0;
-		flush_sendbuffer(handle);
+		retval = -1;
 		while (retval != 0	/*&& errno == ENOENT */
 		       && numloops < recheck_tries) {
 			DEBUG(SCANNEDONLY_DEBUG,
-			      ("scannedonly_allow_access, wait (try=%d "
-			       "(max %d), %d ms) for %s\n",
-			       numloops, recheck_tries,
+			      ("%s: wait (try=%d (max %d), %d ms) for %s\n",
+			       __func__, numloops, recheck_tries,
 			       recheck_time, cache_smb_fname->base_name));
 			smb_msleep(recheck_time);
 			retval = SMB_VFS_NEXT_STAT(handle, cache_smb_fname);
@@ -491,14 +549,18 @@
 		if (sDIR)
 			sDIR->recheck_tries_done = numloops;
 	}
+
 	/* still no cachefile, or still too old, return 0 */
 	if (retval != 0
 	    || !timespec_is_newer(&smb_fname->st.st_ex_ctime,
 				  &cache_smb_fname->st.st_ex_ctime)) {
 		DEBUG(SCANNEDONLY_DEBUG,
-		      ("retval=%d, return 0\n",retval));
+			("%s: retval=%d, returning false\n",
+				__func__, retval));
+		talloc_free(frame);
 		return false;
 	}
+	talloc_free(frame);
 	return true;
 }
 
@@ -510,95 +572,134 @@
 					   const char *fname,
 					   const char *mask, uint32 attr)
 {
-	DIR *DIRp;
-	struct scannedonly_DIR *sDIR;
+	DIR *DIRp = NULL;
+	struct Tscannedonly *data = NULL;
+	struct scannedonly_DIR *sDIR = NULL;
 
 	DIRp = SMB_VFS_NEXT_OPENDIR(handle, fname, mask, attr);
 	if (!DIRp) {
 		return NULL;
 	}
 
-	sDIR = talloc(NULL, struct scannedonly_DIR);
+	SMB_VFS_HANDLE_GET_DATA(handle, data, struct Tscannedonly,
+				return NULL);
+	sDIR = talloc_zero(data, struct scannedonly_DIR);
+	if (!sDIR) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return NULL;
+	}
+	data->dir_data = sDIR;
+
 	if (fname[0] != '/') {
-		sDIR->base = construct_full_path(sDIR,handle, fname, true);
+		sDIR->base = construct_full_path(sDIR, handle, fname, true);
 	} else {
 		sDIR->base = name_w_ending_slash(sDIR, fname);
 	}
 	DEBUG(SCANNEDONLY_DEBUG,
-			("scannedonly_opendir, fname=%s, base=%s\n",fname,sDIR->base));
+		("%s: fname=%s, base=%s\n", __func__, fname, sDIR->base));
 	sDIR->DIR = DIRp;
 	sDIR->recheck_tries_done = 0;
-	return (DIR *) sDIR;
+
+	return DIRp;
 }
 
 static DIR *scannedonly_fdopendir(vfs_handle_struct * handle,
 					   files_struct *fsp,
 					   const char *mask, uint32 attr)
 {
-	DIR *DIRp;
+	DIR *DIRp = NULL;
 	struct scannedonly_DIR *sDIR;
 	const char *fname;
+	struct Tscannedonly *data = NULL;
 
 	DIRp = SMB_VFS_NEXT_FDOPENDIR(handle, fsp, mask, attr);
 	if (!DIRp) {
 		return NULL;
 	}
 
-	fname = (const char *)fsp->fsp_name->base_name;
+	SMB_VFS_HANDLE_GET_DATA(handle, data, struct Tscannedonly,
+				return NULL);
+	sDIR = talloc(data, struct scannedonly_DIR);
+	if (!sDIR) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return NULL;
+	}
+	data->dir_data = sDIR;
 
-	sDIR = talloc(NULL, struct scannedonly_DIR);
+	fname = (const char *)fsp->fsp_name->base_name;
 	if (fname[0] != '/') {
-		sDIR->base = construct_full_path(sDIR,handle, fname, true);
+		sDIR->base = construct_full_path(sDIR, handle, fname, true);
 	} else {
 		sDIR->base = name_w_ending_slash(sDIR, fname);
 	}
 	DEBUG(SCANNEDONLY_DEBUG,
-			("scannedonly_fdopendir, fname=%s, base=%s\n",fname,sDIR->base));
+		("%s: fname=%s, base=%s\n", __func__, fname, sDIR->base));
 	sDIR->DIR = DIRp;
 	sDIR->recheck_tries_done = 0;
-	return (DIR *) sDIR;
-}
 
+	return DIRp;
+}
 
 static struct dirent *scannedonly_readdir(vfs_handle_struct *handle,
-					      DIR * dirp,
-					      SMB_STRUCT_STAT *sbuf)
+					DIR * dirp,
+					SMB_STRUCT_STAT *sbuf)
 {
-	struct dirent *result;
+	struct dirent *result = NULL;
+	struct dirent *newdirent = NULL;
 	int allowed = 0;
-	char *tmp;
-	struct smb_filename *smb_fname;
-	char *notify_name;
-	int namelen;
-	struct dirent *newdirent;
-	TALLOC_CTX *ctx=talloc_tos();
-
-	struct scannedonly_DIR *sDIR = (struct scannedonly_DIR *)dirp;
-	if (!dirp) {
+	char *tmp = NULL;
+	struct smb_filename *smb_fname = NULL;
+	char *notify_name = NULL;
+	int namelen = 0;
+	struct Tscannedonly *data = NULL;
+	struct scannedonly_DIR *sDIR = NULL;
+	TALLOC_CTX *frame = talloc_stackframe();
+
+	SMB_VFS_HANDLE_GET_DATA(handle, data, struct Tscannedonly,
+			return NULL);
+	sDIR = data->dir_data;
+	if (!sDIR) {
+		DEBUG(0, ("%s: dir_data not found\n", __func__));
+		talloc_free(frame);
 		return NULL;
 	}
 
 	result = SMB_VFS_NEXT_READDIR(handle, sDIR->DIR, sbuf);
-
-	if (!result)
+	if (!result) {
+		talloc_free(frame);
 		return NULL;
+	}
 
-	if (is_scannedonly_file(STRUCTSCANO(handle->data), result->d_name)) {
+	if (scannedonly_is_scannedonly_file(data, result->d_name)) {
 		DEBUG(SCANNEDONLY_DEBUG,
-		      ("scannedonly_readdir, %s is a scannedonly file, "
-		       "skip to next entry\n", result->d_name));
+			("%s: %s is a scannedonly file, skip to next entry\n",
+				__func__, result->d_name));
+		talloc_free(frame);
 		return scannedonly_readdir(handle, dirp, NULL);
 	}
-	tmp = talloc_asprintf(ctx, "%s%s", sDIR->base, result->d_name);
+	tmp = talloc_asprintf(talloc_tos(), "%s%s", sDIR->base, result->d_name);
+	if (!tmp) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return NULL;
+	}
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("scannedonly_readdir, check access to %s (sbuf=%p)\n",
-	       tmp,sbuf));
+		("%s: check access to %s (sbuf=%p)\n", __func__, tmp, sbuf));
 
 	/* even if we don't hide nonscanned files or we allow non scanned
-	   files we call allow_access because it will notify the daemon to
-	   scan these files */
-	smb_fname = synthetic_smb_fname(ctx, tmp,NULL,
+	 * files we call allow_access because it will notify the daemon to
+	 * scan these files */
+	smb_fname = synthetic_smb_fname(talloc_tos(), tmp, NULL,
 					sbuf?VALID_STAT(*sbuf)?sbuf:NULL:NULL);
+	if (!smb_fname) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return NULL;
+	}
 	allowed = scannedonly_allow_access(
 		handle, sDIR, smb_fname,
 		result->d_name,
@@ -610,71 +711,63 @@
 		-1,
 		1);
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("scannedonly_readdir access to %s (%s) = %d\n", tmp,
-	       result->d_name, allowed));
+	      ("%s: access to %s (%s) = %d\n", __func__, tmp, result->d_name, allowed));
 	if (allowed) {
+		talloc_free(frame);
 		return result;
 	}
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("hide_nonscanned_files=%d, allow_nonscanned_files=%d\n",
-	       STRUCTSCANO(handle->data)->hide_nonscanned_files,
-	       STRUCTSCANO(handle->data)->allow_nonscanned_files
-		      ));
+	      ("%s: hide_nonscanned_files=%d, allow_nonscanned_files=%d\n",
+		__func__,
+		data->hide_nonscanned_files,
+		data->allow_nonscanned_files));
 
-	if (!STRUCTSCANO(handle->data)->hide_nonscanned_files
-	    || STRUCTSCANO(handle->data)->allow_nonscanned_files) {
+	if (!data->hide_nonscanned_files || data->allow_nonscanned_files) {
+		talloc_free(frame);
 		return result;
 	}
 
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("scannedonly_readdir, readdir listing for %s not "
-	       "allowed, notify user\n", result->d_name));
-	notify_name = talloc_asprintf(
-		ctx,"%s %s",result->d_name,
-		STRUCTSCANO(handle->data)->scanning_message);
+		("%s: readdir listing for %s not allowed, notify user\n",
+			__func__, result->d_name));
+	notify_name = talloc_asprintf(talloc_tos(), "%s %s", result->d_name,
+		data->scanning_message);
+	if (!notify_name) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return NULL;
+	}
 	namelen = strlen(notify_name);
-	newdirent = (struct dirent *)talloc_array(
-		ctx, char, sizeof(struct dirent) + namelen + 1);
+	newdirent = (struct dirent *)talloc_array(handle, char,  sizeof(struct dirent) + namelen + 1);
 	if (!newdirent) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
 		return NULL;
 	}
 	memcpy(newdirent, result, sizeof(struct dirent));
 	memcpy(&newdirent->d_name, notify_name, namelen + 1);
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("scannedonly_readdir, return newdirent at %p with "
-	       "notification %s\n", newdirent, newdirent->d_name));
+	      ("%s: return newdirent at %p with "
+	       "notification %s\n", __func__, newdirent, newdirent->d_name));
+	talloc_free(frame);
 	return newdirent;
 }
 
-static void scannedonly_seekdir(struct vfs_handle_struct *handle,
-				DIR * dirp, long offset)
-{
-	struct scannedonly_DIR *sDIR = (struct scannedonly_DIR *)dirp;
-	SMB_VFS_NEXT_SEEKDIR(handle, sDIR->DIR, offset);
-}
-
-static long scannedonly_telldir(struct vfs_handle_struct *handle,
-				DIR * dirp)
-{
-	struct scannedonly_DIR *sDIR = (struct scannedonly_DIR *)dirp;
-	return SMB_VFS_NEXT_TELLDIR(handle, sDIR->DIR);
-}
-
-static void scannedonly_rewinddir(struct vfs_handle_struct *handle,
-				  DIR * dirp)
-{
-	struct scannedonly_DIR *sDIR = (struct scannedonly_DIR *)dirp;
-	SMB_VFS_NEXT_REWINDDIR(handle, sDIR->DIR);
-}
-
 static int scannedonly_closedir(vfs_handle_struct * handle,
 				DIR * dirp)
 {
-	int retval;
-	struct scannedonly_DIR *sDIR = (struct scannedonly_DIR *)dirp;
-	flush_sendbuffer(handle);
-	retval = SMB_VFS_NEXT_CLOSEDIR(handle, sDIR->DIR);
+	int retval = -1;
+	struct Tscannedonly *data = NULL;
+	struct scannedonly_DIR *sDIR = NULL;
+	SMB_VFS_HANDLE_GET_DATA(handle, data, struct Tscannedonly, return -1);
+	if (data) {
+		sDIR = data->dir_data;
+	}
+	retval = SMB_VFS_NEXT_CLOSEDIR(handle, dirp);
 	TALLOC_FREE(sDIR);
+	data->dir_data = NULL;
 	return retval;
 }
 
@@ -683,25 +776,30 @@
 {
 	int ret;
 	ret = SMB_VFS_NEXT_STAT(handle, smb_fname);
-	DEBUG(SCANNEDONLY_DEBUG, ("scannedonly_stat: %s returned %d\n",
-				  smb_fname->base_name, ret));
+	DEBUG(SCANNEDONLY_DEBUG,
+		("%s: %s returned %d\n", __func__,
+			smb_fname->base_name, ret));
 	if (ret != 0 && errno == ENOENT) {
-		TALLOC_CTX *ctx=talloc_tos();
-		char *test_base_name, *tmp_base_name = smb_fname->base_name;
+		TALLOC_CTX *frame = talloc_stackframe();
+		char *test_base_name = NULL;
+		char *tmp_base_name = smb_fname->base_name;
+
 		/* possibly this was a fake name (file is being scanned for
 		   viruses.txt): check for that and create the real name and
 		   stat the real name */
 		test_base_name = real_path_from_notify_path(
-			ctx,
+			talloc_tos(),
 			STRUCTSCANO(handle->data),
 			smb_fname->base_name);
 		if (test_base_name) {
 			smb_fname->base_name = test_base_name;
 			ret = SMB_VFS_NEXT_STAT(handle, smb_fname);
-			DEBUG(5, ("_stat: %s returned %d\n",
-				  test_base_name, ret));
+			DEBUG(SCANNEDONLY_DEBUG,
+				("%s: %s returned %d\n", __func__,
+					test_base_name, ret));
 			smb_fname->base_name = tmp_base_name;
 		}
+		talloc_free(frame);
 	}
 	return ret;
 }
@@ -711,23 +809,28 @@
 {
 	int ret;
 	ret = SMB_VFS_NEXT_LSTAT(handle, smb_fname);
-	DEBUG(SCANNEDONLY_DEBUG, ("scannedonly_lstat: %s returned %d\n",
-				  smb_fname->base_name, ret));
+	DEBUG(SCANNEDONLY_DEBUG,
+		("%s: %s returned %d\n", __func__,
+			smb_fname->base_name, ret));
 	if (ret != 0 && errno == ENOENT) {
-		TALLOC_CTX *ctx=talloc_tos();
-		char *test_base_name, *tmp_base_name = smb_fname->base_name;
+		TALLOC_CTX *frame = talloc_stackframe();
+		char *test_base_name = NULL;
+		char *tmp_base_name = smb_fname->base_name;
+
 		/* possibly this was a fake name (file is being scanned for
 		   viruses.txt): check for that and create the real name and
 		   stat the real name */
 		test_base_name = real_path_from_notify_path(
-			ctx, STRUCTSCANO(handle->data), smb_fname->base_name);
+			talloc_tos(), STRUCTSCANO(handle->data), smb_fname->base_name);
 		if (test_base_name) {
 			smb_fname->base_name = test_base_name;
 			ret = SMB_VFS_NEXT_LSTAT(handle, smb_fname);
-			DEBUG(5, ("_lstat: %s returned %d\n",
-				  test_base_name, ret));
+			DEBUG(SCANNEDONLY_DEBUG,
+				("%s: %s returned %d\n", __func__,
+					test_base_name, ret));
 			smb_fname->base_name = tmp_base_name;
 		}
+		talloc_free(frame);
 	}
 	return ret;
 }
@@ -736,10 +839,14 @@
 			    struct smb_filename *smb_fname,
 			    files_struct * fsp, int flags, mode_t mode)
 {
-	const char *base;
-	char *tmp, *shortname;
-	int allowed, write_access = 0;
-	TALLOC_CTX *ctx=talloc_tos();
+	char *tmp = NULL;
+	char *base = NULL;
+	char *shortname = NULL;
+	int allowed = 0;
+	int write_access = 0;
+	int retval = -1;
+	TALLOC_CTX *frame = talloc_stackframe();
+
 	/* if open for writing ignore it */
 	if ((flags & O_ACCMODE) == O_WRONLY) {
 		return SMB_VFS_NEXT_OPEN(handle, smb_fname, fsp, flags, mode);
@@ -747,45 +854,56 @@
 	if ((flags & O_ACCMODE) == O_RDWR) {
 		write_access = 1;
 	}
+
 	/* check if this file is scanned already */
 	tmp = strrchr(smb_fname->base_name, '/');
 	if (tmp) {
-		base = talloc_strndup(ctx,smb_fname->base_name,
-				      (tmp - smb_fname->base_name) + 1);
-		shortname = tmp + 1;
+		base = talloc_strndup(talloc_tos(), smb_fname->base_name,
+			(tmp - smb_fname->base_name) + 1);
+		shortname = talloc_strdup(talloc_tos(), tmp + 1);
 	} else {
-		base = "";
-		shortname = (char *)smb_fname->base_name;
+		base = talloc_strdup(talloc_tos(), "");
+		shortname = talloc_strdup(talloc_tos(), smb_fname->base_name);
 	}
+	if (!base || !shortname) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		talloc_free(frame);
+		errno = ENOMEM;
+		return -1;
+	}
+
 	allowed = scannedonly_allow_access(
-		handle, NULL, smb_fname, shortname,
-		base,
-		write_access,
+		handle, NULL, smb_fname, shortname, base, write_access,
 		STRUCTSCANO(handle->data)->recheck_time_open,
 		STRUCTSCANO(handle->data)->recheck_tries_open,
 		STRUCTSCANO(handle->data)->recheck_size_open,
 		0);
-	flush_sendbuffer(handle);
-	DEBUG(SCANNEDONLY_DEBUG, ("scannedonly_open: allow=%d for %s\n",
-				  allowed, smb_fname->base_name));
-	if (allowed
-	    || STRUCTSCANO(handle->data)->allow_nonscanned_files) {
-		return SMB_VFS_NEXT_OPEN(handle, smb_fname, fsp, flags, mode);
+
+	DEBUG(SCANNEDONLY_DEBUG, ("%s: allow=%d for %s\n", __func__,
+		allowed, smb_fname->base_name));
+	if (allowed || STRUCTSCANO(handle->data)->allow_nonscanned_files) {
+		retval = SMB_VFS_NEXT_OPEN(handle, smb_fname, fsp, flags, mode);
+	} else {
+		retval = -1;
+		errno = EACCES;
 	}
-	errno = EACCES;
-	return -1;
+
+	talloc_free(shortname);
+	talloc_free(base);
+	talloc_free(frame);
+	return retval;
 }
 
 static int scannedonly_close(vfs_handle_struct * handle, files_struct * fsp)
 {
-	/* we only have to notify the scanner
-	   for files that were open readwrite or writable. */
+	/* we only have to notify the scanner for files that were open
+	 * readwrite or writable. */
 	if (fsp->can_write) {
-		TALLOC_CTX *ctx = talloc_tos();
-		notify_scanner(handle, construct_full_path(
-				       ctx,handle,
+		TALLOC_CTX *frame = talloc_stackframe();
+		scannedonly_notify_scanner(handle, construct_full_path(
+				       talloc_tos() ,handle,
 				       fsp->fsp_name->base_name,false));
-		flush_sendbuffer(handle);
+		talloc_free(frame);
 	}
 	return SMB_VFS_NEXT_CLOSE(handle, fsp);
 }
@@ -797,99 +915,206 @@
 	/* rename the cache file before we pass the actual rename on */
 	struct smb_filename *smb_fname_src_tmp = NULL;
 	struct smb_filename *smb_fname_dst_tmp = NULL;
-	char *cachefile_src, *cachefile_dst;
-	bool needscandst=false;
-	int ret;
-	TALLOC_CTX *ctx = talloc_tos();
+	char *cachefile_src = NULL;
+	char *cachefile_dst = NULL;
+	bool needscandst = false;
+	int ret = -1;
+	TALLOC_CTX *frame = talloc_stackframe();
 
 	/* Setup temporary smb_filename structs. */
 	cachefile_src = cachefile_name_f_fullpath(
-		ctx,
+		talloc_tos(),
 		smb_fname_src->base_name,
 		STRUCTSCANO(handle->data)->p_scanned);
+	if (!cachefile_src) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return -1;
+	}
+
 	cachefile_dst =	cachefile_name_f_fullpath(
-		ctx,
+		talloc_tos(),
 		smb_fname_dst->base_name,
 		STRUCTSCANO(handle->data)->p_scanned);
-	smb_fname_src_tmp = synthetic_smb_fname(ctx, cachefile_src,NULL,NULL);
-	smb_fname_dst_tmp = synthetic_smb_fname(ctx, cachefile_dst,NULL,NULL);
+	if (!cachefile_dst) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return -1;
+	}
+
+	smb_fname_src_tmp = synthetic_smb_fname(talloc_tos(), cachefile_src,
+				NULL,NULL);
+	if (!smb_fname_src_tmp) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return -1;
+	}
+
+	smb_fname_dst_tmp = synthetic_smb_fname(talloc_tos(), cachefile_dst,
+				NULL,NULL);
+	if (!smb_fname_dst_tmp) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		return -1;
+	}
 
 	ret = SMB_VFS_NEXT_RENAME(handle, smb_fname_src_tmp, smb_fname_dst_tmp);
 	if (ret == ENOENT) {
-		needscandst=true;
+		needscandst = true;
 	} else if (ret != 0) {
-		DEBUG(SCANNEDONLY_DEBUG,
-		      ("failed to rename %s into %s error %d: %s\n", cachefile_src,
-		       cachefile_dst, ret, strerror(ret)));
-		needscandst=true;
+		DEBUG(0, ("%s: failed to rename %s into %s error %d: %s\n", __func__,
+			cachefile_src, cachefile_dst, ret, strerror(ret)));
+		needscandst = true;
 	}
+
 	ret = SMB_VFS_NEXT_RENAME(handle, smb_fname_src, smb_fname_dst);
 	if (ret == 0 && needscandst) {
-		notify_scanner(handle, smb_fname_dst->base_name);
-		flush_sendbuffer(handle);
+		scannedonly_notify_scanner(handle, smb_fname_dst->base_name);
 	}
+	talloc_free(smb_fname_dst_tmp);
+	talloc_free(smb_fname_src_tmp);
+	talloc_free(cachefile_dst);
+	talloc_free(cachefile_src);
+	talloc_free(frame);
+
 	return ret;
 }
 
 static int scannedonly_unlink(vfs_handle_struct * handle,
 			      const struct smb_filename *smb_fname)
 {
-	/* unlink the 'scanned' file too */
+	int ret = -1;
 	struct smb_filename *smb_fname_cache = NULL;
-	char * cachefile;
-	TALLOC_CTX *ctx = talloc_tos();
+	char *cachefile = NULL;
+	TALLOC_CTX *frame = talloc_stackframe();
 
-	cachefile = cachefile_name_f_fullpath(
-		ctx,
+	/* unlink the 'scanned' file too */
+	cachefile = cachefile_name_f_fullpath(talloc_tos(),
 		smb_fname->base_name,
 		STRUCTSCANO(handle->data)->p_scanned);
-	smb_fname_cache = synthetic_smb_fname(ctx, cachefile,NULL,NULL);
-	if (SMB_VFS_NEXT_UNLINK(handle, smb_fname_cache) != 0) {
-		DEBUG(SCANNEDONLY_DEBUG, ("_unlink: failed to unlink %s\n",
-					  smb_fname_cache->base_name));
+	if (!cachefile) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	smb_fname_cache = synthetic_smb_fname(talloc_tos(), cachefile, NULL, NULL);
+	if (!smb_fname_cache) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	ret = SMB_VFS_NEXT_STAT(handle, smb_fname_cache);
+	if (ret == 0) {
+	    if (SMB_VFS_NEXT_UNLINK(handle, smb_fname_cache) != 0) {
+			DEBUG(0, ("%s: failed to unlink %s (%d - %s)\n", __func__,
+				smb_fname_cache->base_name, ret, strerror(ret)));
+		}
+	}
+	TALLOC_FREE(smb_fname_cache);
+	TALLOC_FREE(cachefile);
+
+	/* unlink the 'failed' file too */
+	cachefile = cachefile_name_f_fullpath(talloc_tos(),
+		smb_fname->base_name, STRUCTSCANO(handle->data)->p_failed);
+	if (!cachefile) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	smb_fname_cache = synthetic_smb_fname(talloc_tos(), cachefile,
+		NULL, NULL);
+	if (!smb_fname_cache) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	ret = SMB_VFS_NEXT_STAT(handle, smb_fname_cache);
+	if (ret == 0) {
+		if (SMB_VFS_NEXT_UNLINK(handle, smb_fname_cache) != 0) {
+			DEBUG(0, ("%s: failed to unlink %s (%d - %s)\n", __func__,
+				smb_fname_cache->base_name, ret, strerror(ret)));
+		}
 	}
+
+	TALLOC_FREE(smb_fname_cache);
+	TALLOC_FREE(cachefile);
+	talloc_free(frame);
 	return SMB_VFS_NEXT_UNLINK(handle, smb_fname);
 }
 
 static int scannedonly_rmdir(vfs_handle_struct * handle, const char *path)
 {
 	/* if there are only .scanned: .virus: or .failed: files, we delete
-	   those, because the client cannot see them */
-	DIR *dirp;
-	struct dirent *dire;
-	TALLOC_CTX *ctx = talloc_tos();
-	bool only_deletable_files = true, have_files = false;
-	char *path_w_slash;
+	 * those, because the client cannot see them */
+	DIR *dirp = NULL;
+	struct dirent *dire = NULL;
+	bool only_deletable_files = true;
+	bool have_files = false;
+	char *path_w_slash = NULL;
+	int ret = -1;
+	struct Tscannedonly *data = NULL;
+	TALLOC_CTX *frame = talloc_stackframe();
+
+	SMB_VFS_HANDLE_GET_DATA(handle, data, struct Tscannedonly,
+				return -1);
 
-	if (!STRUCTSCANO(handle->data)->rm_hidden_files_on_rmdir)
+	if (!data->rm_hidden_files_on_rmdir) {
+		talloc_free(frame);
 		return SMB_VFS_NEXT_RMDIR(handle, path);
+	}
 
-	path_w_slash = name_w_ending_slash(ctx,path);
+	path_w_slash = name_w_ending_slash(talloc_tos(), path);
+	if (!path_w_slash) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
 	dirp = SMB_VFS_NEXT_OPENDIR(handle, path, NULL, 0);
 	if (!dirp) {
+		talloc_free(frame);
 		return -1;
 	}
+
 	while ((dire = SMB_VFS_NEXT_READDIR(handle, dirp, NULL)) != NULL) {
 		if (ISDOT(dire->d_name) || ISDOTDOT(dire->d_name)) {
 			continue;
 		}
 		have_files = true;
-		if (!is_scannedonly_file(STRUCTSCANO(handle->data),
-					 dire->d_name)) {
+		if (!scannedonly_is_scannedonly_file(data, dire->d_name)) {
 			struct smb_filename *smb_fname = NULL;
-			char *fullpath;
-			int retval;
+			char *fullpath = NULL;
+			int retval = -1;
 
-			if (STRUCTSCANO(handle->data)->show_special_files) {
+			if (data->show_special_files) {
 				only_deletable_files = false;
 				break;
 			}
-			/* stat the file and see if it is a
-			   special file */
-			fullpath = talloc_asprintf(ctx, "%s%s", path_w_slash,
-						  dire->d_name);
-			smb_fname = synthetic_smb_fname(ctx, fullpath,
+			/* stat the file and see if it is a special file */
+			fullpath = talloc_asprintf(talloc_tos(), "%s%s",
+					path_w_slash, dire->d_name);
+			if (!fullpath) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return errno;
+			}
+			smb_fname = synthetic_smb_fname(talloc_tos(), fullpath,
 							NULL,NULL);
+			if (!smb_fname) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return errno;
+			}
 			retval = SMB_VFS_NEXT_STAT(handle, smb_fname);
 			if (retval == 0
 			    && S_ISREG(smb_fname->st.st_ex_mode)) {
@@ -901,37 +1126,113 @@
 		}
 	}
 	DEBUG(SCANNEDONLY_DEBUG,
-	      ("path=%s, have_files=%d, only_deletable_files=%d\n",
-	       path, have_files, only_deletable_files));
+	      ("%s: path=%s, have_files=%d, only_deletable_files=%d\n",
+	       __func__, path, have_files, only_deletable_files));
 	if (have_files && only_deletable_files) {
 		DEBUG(SCANNEDONLY_DEBUG,
-		      ("scannedonly_rmdir, remove leftover scannedonly "
-		       "files from %s\n", path_w_slash));
+			("%s: remove leftover scannedonly files from %s\n",
+				__func__, path_w_slash));
 		SMB_VFS_NEXT_REWINDDIR(handle, dirp);
-		while ((dire = SMB_VFS_NEXT_READDIR(handle, dirp, NULL))
-		       != NULL) {
-			char *fullpath;
+		while ((dire = SMB_VFS_NEXT_READDIR(handle, dirp, NULL)) != NULL) {
+			char *fullpath = NULL;
 			struct smb_filename *smb_fname = NULL;
 			if (ISDOT(dire->d_name) || ISDOTDOT(dire->d_name)) {
 				continue;
 			}
-			fullpath = talloc_asprintf(ctx, "%s%s", path_w_slash,
+			fullpath = talloc_asprintf(talloc_tos(), "%s%s", path_w_slash,
 						  dire->d_name);
-			smb_fname = synthetic_smb_fname(ctx, fullpath,
+			if (!fullpath) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return errno;
+			}
+			smb_fname = synthetic_smb_fname(talloc_tos(), fullpath,
 							NULL,NULL);
-			DEBUG(SCANNEDONLY_DEBUG, ("unlink %s\n", fullpath));
+			if (!smb_fname) {
+				DEBUG(0, ("%s: No memory\n", __func__));
+				errno = ENOMEM;
+				talloc_free(frame);
+				return errno;
+			}
+			DEBUG(SCANNEDONLY_DEBUG, ("%s: unlink %s\n", __func__, fullpath));
 			SMB_VFS_NEXT_UNLINK(handle, smb_fname);
 			TALLOC_FREE(fullpath);
 			TALLOC_FREE(smb_fname);
 		}
 	}
 	SMB_VFS_NEXT_CLOSEDIR(handle, dirp);
+
+	/* unlink the 'scanned' file too */
+	struct smb_filename *smb_fname_cache = NULL;
+	char *cachefile = NULL;
+	cachefile = cachefile_name_f_fullpath(talloc_tos(), path, data->p_scanned);
+	if (!cachefile) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+	smb_fname_cache = synthetic_smb_fname(talloc_tos(), cachefile, NULL,NULL);
+	if (!smb_fname_cache) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+	ret = SMB_VFS_NEXT_STAT(handle, smb_fname_cache);
+	if (ret == 0) {
+		if (SMB_VFS_NEXT_UNLINK(handle, smb_fname_cache) != 0) {
+			DEBUG(0, ("%s: failed to unlink %s (%d %s)\n",
+				__func__, smb_fname_cache->base_name, errno,
+				strerror(errno)));
+		}
+	}
+	TALLOC_FREE(smb_fname_cache);
+	TALLOC_FREE(cachefile);
+
+	/* unlink the 'failed' file too */
+	cachefile = cachefile_name_f_fullpath(talloc_tos(), path, data->p_failed);
+	if (!cachefile) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	smb_fname_cache = synthetic_smb_fname(talloc_tos(), cachefile, NULL, NULL);
+	if (!smb_fname_cache) {
+		DEBUG(0, ("%s: No memory\n", __func__));
+		errno = ENOMEM;
+		talloc_free(frame);
+		return errno;
+	}
+
+	ret = SMB_VFS_NEXT_STAT(handle, smb_fname_cache);
+	if (ret == 0) {
+		if (SMB_VFS_NEXT_UNLINK(handle, smb_fname_cache) != 0) {
+			DEBUG(0, ("%s: failed to unlink %s (%d %s)\n",
+				__func__, smb_fname_cache->base_name,
+				errno, strerror(errno)));
+		}
+	}
+	TALLOC_FREE(smb_fname_cache);
+	TALLOC_FREE(cachefile);
+	TALLOC_FREE(frame);
+
 	return SMB_VFS_NEXT_RMDIR(handle, path);
 }
 
-static void free_scannedonly_data(void **data)
+static void scannedonly_free_data(void **datap)
 {
-	SAFE_FREE(*data);
+	struct Tscannedonly **data = (struct Tscannedonly **)datap;
+	if (!data)
+		return;
+
+	if (*data) {
+		DEBUG(SCANNEDONLY_DEBUG, ("%s: free private data\n", __func__));
+		TALLOC_FREE(*data);
+	}
 }
 
 static int scannedonly_connect(struct vfs_handle_struct *handle,
@@ -940,14 +1241,16 @@
 
 	struct Tscannedonly *so;
 
-	so = SMB_MALLOC_P(struct Tscannedonly);
+	so = talloc_zero(handle, struct Tscannedonly);
 	if (so == NULL) {
+		SMB_VFS_NEXT_DISCONNECT(handle);
 		errno = ENOMEM;
 		return -1;
 	}
-	handle->data = (void *)so;
-	handle->free_data = free_scannedonly_data;
-	so->gsendbuffer[0]='\0';
+	SMB_VFS_HANDLE_SET_DATA(handle, so, scannedonly_free_data,
+				struct Tscannedonly, return -1);
+
+	so->dir_data = NULL;
 	so->domain_socket =
 		lp_parm_bool(SNUM(handle->conn), "scannedonly",
 			     "domain_socket", True);
@@ -1010,19 +1313,23 @@
 					     "scannedonly",
 					     "pref_failed",
 					     ".failed:");
-	connect_to_scanner(handle);
+	scannedonly_connect_to_scanner(handle);
 
 	return SMB_VFS_NEXT_CONNECT(handle, service, user);
 }
 
+static void scannedonly_disconnect(struct vfs_handle_struct *handle)
+{
+        SMB_VFS_NEXT_DISCONNECT(handle);
+}
+
 /* VFS operations structure */
 static struct vfs_fn_pointers vfs_scannedonly_fns = {
+	.connect_fn = scannedonly_connect,
+	.disconnect_fn = scannedonly_disconnect,
 	.opendir_fn = scannedonly_opendir,
 	.fdopendir_fn = scannedonly_fdopendir,
 	.readdir_fn = scannedonly_readdir,
-	.seekdir_fn = scannedonly_seekdir,
-	.telldir_fn = scannedonly_telldir,
-	.rewind_dir_fn = scannedonly_rewinddir,
 	.closedir_fn = scannedonly_closedir,
 	.rmdir_fn = scannedonly_rmdir,
 	.stat_fn = scannedonly_stat,
@@ -1031,7 +1338,6 @@
 	.close_fn = scannedonly_close,
 	.rename_fn = scannedonly_rename,
 	.unlink_fn = scannedonly_unlink,
-	.connect_fn = scannedonly_connect
 };
 
 NTSTATUS vfs_scannedonly_init(void)
