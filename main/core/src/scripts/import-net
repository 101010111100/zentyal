# Copyright (C) 2012 EBox Technologies S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use warnings;

use EBox;
use EBox::Global;
use EBox::Sudo;
use Error qw(:try);
use YAML::XS;
use File::Slurp;
use File::Basename qw(dirname basename);

my %moduleParameters = (
    objects => {
        modelDirs => {
            ObjectTable => 'objectTable',
            MemberTable => 'members',
           },
       },
    services => {
        modelDirs => {
            ServiceTable => 'serviceTable',
            ServiceConfigurationTable => 'serviceConfigurationTable',
           },
        rowAdapter => {
               'ServiceTable' => \&_serviceTableRowAdapter,
           },
       },
);

# XXX accomadete changes i nservices fields
# XXX discriminte between datatable and dataforn?
# XXX remember initlaSetup for services module
# XX clean all conf before importing, seems to rmeoveALL odes not cut it
EBox::init();

my ($bakDir) = @ARGV;
my %oldConf;


_importServices($bakDir, \%oldConf);
_importSimpleModule('objects', $bakDir);
# _importNetwork($bakDir,  \%oldConf);
# _importFirewall($bakDir, \%oldConf);


sub _importServices
{
    my ($bakDir, $oldConf) = @_;
    my $modName = 'services';

    my $bakData = _parseBakfile($bakDir, $modName);
    if (not $bakData) {
        return;
    }

    use Data::Dumper;
#    print Dumper ($bakData);

    my $tree = _moduleComponentTree($modName);
 #   print Dumper($tree);

    my $servicesMod = EBox::Global->getInstance(0)->modInstance($modName);
    my $filled = _fillModuleTree($servicesMod, $tree, $bakData);
    print Dumper($filled);

    _insertFilledTreeIntoModule($servicesMod, $filled);
}

sub _importSimpleModule
{
    my ($modName, $bakDir) = @_;
    my $bakData = _parseBakfile($bakDir, $modName);
    if (not $bakData) {
        return;
    }
    my $tree = _moduleComponentTree($modName);
 #   print Dumper($tree);

    my $module = EBox::Global->getInstance(0)->modInstance($modName);
    my $filled = _fillModuleTree($module, $tree, $bakData);
    print Dumper($filled);

    _insertFilledTreeIntoModule($module, $filled);
}

sub _moduleComponentTree
{
    my ($modName) = @_;
    my $global = EBox::Global->getInstance();
    my $modInfo = $global->readModInfo($modName);

    my $models       = $modInfo->{models};
    my $childsByParent = $modInfo->{foreign};
    my $composites =  $modInfo->{composites};

    # assumed that composite and model cannot have the same name
    my %rootComponents;
    foreach my $component (@{ $models }, keys %{ $composites }) {
        $rootComponents{$component} = 1;
    }
    foreach my $childs (values %{ $childsByParent}, values %{ $composites }  ) {
        foreach my $child (@{ $childs }) {
            delete $rootComponents{$child};
        }
    }

    my $modelsByName = {
                             map { ($_ => $_ )  } @{ $models }
                       };
    my @tree;
    foreach my $name (keys %rootComponents) {
        push @tree, _componentForTree($name, $modelsByName, $childsByParent, $composites);
    }
    return \@tree;
}

sub _componentForTree
{
    my ($componentName, $models, $childByParent, $composites) = @_;
    my $component = { name => $componentName};
    my $childNames;
    if (exists $models->{$componentName}) {
        $component->{type} = 'model';
        $childNames = $childByParent->{$componentName};
    } elsif (exists $composites->{$componentName}) {
        $component->{type} = 'composite';
        $childNames = $composites->{$componentName};
    } else {
        EBox::error("Unknown component type " . $component->{type} . '. Skip');
        return undef;
    }

    if (not $childNames) {
        $childNames = [];
    }

    my @childs;
    foreach my $childName (@{ $childNames }) {
        my $componentChild = _componentForTree($childName, $models, $childByParent, $composites);
        push @childs, $componentChild if $componentChild;
    }
    $component->{childsPrototypes} = \@childs;
    return $component;
}

sub _parseBakfile
{
    my ($dir, $module) = @_;
    my $path = "$dir/$module.bak/$module.bak";
    if (not EBox::Sudo::fileTest('-r', $path)) {
        EBox::info("No backup file for $path for module $module, not restoring it");
        return undef;
    }

    my @keys;
    try {
        my $lines = EBox::Sudo::root("cat $path");
        my $text = join '', @{$lines};
        @keys = YAML::XS::Load($text);
    } otherwise {
        throw EBox::Exceptions::External("Error parsing YAML:$path");
    };
    my %keys = map {
        $_->{key} => $_
    } @keys;


    return \%keys;
}

sub _fillModuleTree
{
    my ($module, $tree, $allKeys) = @_;
    my $moduleName = $module->name();
    my $moduleDir = _moduleDir($moduleName);
    foreach my $root (@{  $tree }) {
        my $dir = $moduleDir;
        if ($root->{type} eq 'model') {
            my $modelName  = $root->{name};
            $dir = _modelDir($moduleName, $modelName, $dir);
        }
        _fillComponent($module, $root, $dir, $allKeys);
    }

    return $tree;
}

sub _fillComponent
{
    my ($module, $compSpec, $dir, $allKeys) = @_;
    if ($compSpec->{type} eq 'composite') {
        die 'TO IMPLEMENT';
    } elsif ($compSpec->{type} eq 'model') {
        _fillModel($module, $compSpec, $dir, $allKeys);
    } else {
        # composite without childs
        EBox::info('Unknown componet type ' . $compSpec->{type} . ' Name ' . $compSpec->{name});
    }
}

sub _fillModel
{
    my ($module, $modelSpec, $dir, $allKeys) = @_;
    if (@{ $modelSpec->{childsPrototypes} }) {
        _fillModelWithChilds($module, $modelSpec, $dir, $allKeys);
    } else {
        _fillModelRows($module, $modelSpec, $dir, $allKeys);
    }
}

sub _fillModelWithChilds
{
    my ($module, $modelSpec, $baseDir, $allKeys) = @_;
    my $dir = $baseDir . '/keys';
    my $moduleName = $module->name();
    my $modelName  = $modelSpec->{name};

    my $idxKeys = _matchKeys($allKeys, $dir, '.*.idx', 'hash');
#    print Dumper($idxKeys); # DDD
    if (@{ $idxKeys } == 0) {
        $modelSpec->{rows} = [];
        return;
    } elsif (@{ $idxKeys } > 1){
        EBox::error("More than one idx key found in $dir/*.idx. Not suppored. Skipped");
        return;
    }

    # XXX asummed only one idx param
    my $idxParam = basename($idxKeys->[0]->{key});
    $idxParam =~ s/\.idx$//;
     if (not $idxParam) {
        EBox::error('Cannot get idx param name from ' .$idxKeys->[0]->{key} . ' Skipping' );
        return;
    }
    my %idxInfo;
    while (my ($value, $rowIdString) = each %{ $idxKeys->[0]->{value}}) {
        $rowIdString =~ m/"(.*?)"/;
        my $rowId = $1;
        if (not $rowId) {
            EBox::error("Cannot get row id from key $rowIdString. Skipping");
            next;
        }
        $idxInfo{$rowId} = $value;
    }

    my @rows;
    my @order = @{  _getModelOrderValue($moduleName, $modelName, $baseDir, $allKeys)  };
#    print "oirder " . Dumper(\@order); #DDD
    foreach my $rowId (@order) {
        my $idxValue = $idxInfo{$rowId};
        if (not $idxValue) {
            EBox::error("No row idx for $rowId. Skipping");
            next;
        }
        my %elements = %{ _elementsForRow($moduleName, $modelName, $dir, $rowId, $allKeys) };
        # add idxparam to elements
        $elements{$idxParam} = $idxValue;
        my @subModels = @{ _subModelsByModelName($module, $modelName) };
        my @childRows;
        foreach my $subModel(@subModels) {
            my $fieldName = $subModel->fieldName();
            my $subModelDir = $dir . "/$rowId/$fieldName";
            my $foreignModel = $subModel->foreignModel();
            my $spec;
            foreach my $child (@{ $modelSpec->{childsPrototypes} }) {
                if ($child->{name} eq $foreignModel) {
                    $spec = Clone::Fast::clone($child);
                    $spec->{subModelField} = $fieldName;
                }
            }
            if (not $spec) {
                EBox::error("Spec not found for $foreignModel");
                next;
            }

            _fillComponent($module, $spec, $subModelDir, $allKeys);
#            print 'row child ' . " directory $subModelDir" .  Dumper($spec); #DDD
            push @childRows, $spec;
        }

        # TODO childs here
        my $row = {
            id => $rowId,
            elements => \%elements,
            childs => \@childRows,
        };
        push @rows, $row;
    }

    $modelSpec->{rows} = \@rows;
}

sub _fillModelRows
{
    my ($module, $modelSpec, $baseDir, $allKeys) = @_;
    my $dir = $baseDir . '/keys';
    my $moduleName = $module->name();
    my $modelName  = $modelSpec->{name};

    my @order = @{  _getModelOrderValue($moduleName, $modelName, $baseDir, $allKeys)  };
    if (not @order) {
        # must be with only one ID, try to found it
        my $onlyRowId = _onlyRowIdForModel($dir, $allKeys);
        if ($onlyRowId) {
            @order = ( $onlyRowId  );
        }
    }
    if (not @order) {
        EBox::info("cannot found order rows on lone row id for $modelName it must be empty");
    }

    my @rows;
    foreach my $rowId (@order) {
        my %elements = %{ _elementsForRow($moduleName, $modelName, $dir, $rowId, $allKeys) };
        if (not %elements) {
            EBox::info("Not found data for row with old id $rowId. Skipping" );
            next;
        }
        my $row = {
            id => $rowId,
            elements => \%elements,
        };
        push @rows, $row;
    }

    $modelSpec->{rows} = \@rows;
}

sub _elementsForRow
{
    my ($moduleName, $modelName, $dir, $rowId, $allKeys) = @_;
    # assumed that no-idx row keys are always of string type
    if (not $rowId) {
        # DDD
        use Devel::StackTrace;
        my $tr = Devel::StackTrace->new();
        die $tr->as_string();
    }
    my $rowDir = "$dir/$rowId";
    my $keysForRow = _matchKeys($allKeys, $rowDir, '.*', 'string');
    if (not @{ $keysForRow }) {
        EBox::info("Not found data for row with old id $rowId. Skipping" );
            next;
        }

    #        print "KEYS FOR ROW $rowId : " . Dumper($keysForRow) . "\n"; # DDD
    my %elements;
    foreach my $key (@{ $keysForRow }) {
        my $name = basename($key->{key});
 #       my $name = $key->{key};
#        $name =~ s{^$rowDir/}{};
        $elements{$name} = $key->{value};
    }

    my $modParams = _moduleParameters($moduleName);
    if ((exists $modParams->{rowAdapter}->{$modelName}) and
        ($modParams->{rowAdapter}->{$modelName})
       ) {
        return $modParams->{rowAdapter}->{$modelName}->(\%elements);
    }

    return \%elements
}

sub _subModelsByModelName
{
    my ($module, $modelName) = @_;
    my $model = $module->model($modelName);
    my $submodelsFields =  $model->_subModelFields();
    if (not @{ $submodelsFields }) {
        EBox::error("Not submodels for model $module/$modelName which has childs!");
    }

    my @submodels = map {
        $model->fieldHeader($_);
    } @{ $submodelsFields };
    return \@submodels;
}

sub _moduleDir
{
    my ($moduleName) = @_;
    return  "/ebox/modules/$moduleName";
}

sub _moduleParameters
{
    my ($moduleName) = @_;
    my $params;
    if (exists $moduleParameters{$moduleName}) {
        $params = $moduleParameters{$moduleName}
    } else {
        $params = {};
    }

    my @hashParams = qw(modelDirs rowAdapter);
    foreach my $param (@hashParams) {
        if (not exists $params->{$param}) {
            $params->{$param} = {};
        }
    }

    return $params;
}

# in 2.2 not all model has directory equal to its name
sub _modelDir
{
    my ($moduleName, $modelName, $dir) = @_;
    my $modelDir;
    my $params = _moduleParameters($moduleName);
    if ( (exists $params->{modelDirs}->{$modelName}) and
         ($params->{modelDirs}->{$modelName})
        ) {
        $modelDir =  $params->{modelDirs}->{$modelName};
    } else {
        $modelDir = $modelName;
    }

    return  "$dir/$modelDir"
}

sub _getModelOrderValue
{
    my ($moduleName, $modelName, $dir, $allKeys) = @_;
    my $orderKey = $dir . '/order';
    if (not exists $allKeys->{$orderKey}) {
        return [];
    }

    my @order = @{ $allKeys->{$orderKey}->{value}  };
    return \@order;
}

sub _onlyRowIdForModel
{
    my ($dir, $allKeys) = @_;
    # try to match something like
    # /ebox/modules/services/serviceTable/keys/serv9837/configuration/keys/serv7815/source_range_type
    my $id;
    my $regex = qr{^$dir/(.*?)/(.*?)$};
    foreach my $key (keys %{ $allKeys }) {
        if ($key =~ m/$regex/) {
            $id = $1;
            last;
        }
    }

    if (not $id) {
        EBox::error("Cannot find only row id for model. Directory $dir");
    }

#    print "ONLY ROW $id\n"; # DDD
    return $id;
}


sub _matchKeys
{
    my ($allKeys, $dir, $basenameRe, $type) = @_;
#    print "_matchKeys $dir \n"; # DDD
    my @matched;
#    my $rexp = qr{^$dir/(.*?)[^/]$};
    foreach my $key (keys %{ $allKeys }) {
#        if ($key =~ m/$rexp/) {
        if (dirname($key) eq $dir) {
            if (not (basename($key) =~ m/$basenameRe/)) {
                next;
            }
            my $selected = $allKeys->{$key};
            if ($type) {
                ($selected->{type} eq $type) or
                    next;
            }
            push @matched, $selected;
        }
    }
    return \@matched;
}

my $clearConf = 1;
sub _insertFilledTreeIntoModule
{
    my ($module, $tree) = @_;
    foreach my $root (@{ $tree }) {
        if ($root->{type}  eq 'model') {
            my $model = $module->model($root->{name});

            _insertRowsInModel($model, $root->{rows});
        }
    }

}

sub _insertRowsInModel
{
    my ($model, $rows) = @_;
    $model->removeAll(1) if $clearConf;
    foreach my $row (@{ $rows }) {
        my $newRowId;
        try {
            $newRowId = $model->addRow(%{ $row->{elements}});
        } otherwise {
            EBox::error("Cannot add row in model " . $model->name() .
                         ' elements ' . Dumper($row->{elements})
                       );
            _die(); #DDD
        };
        $newRowId or
            next;
        my $newRow   = $model->row($newRowId);
        # add childrens
        foreach my $child (@{ $row->{childs}}) {
            my $subModelField = $child->{subModelField};
            my $subModel =  $newRow->subModel($subModelField);
            _insertRowsInModel($subModel, $child->{rows});
        }

    }
}

sub _serviceTableRowAdapter
{
    my ($elements) = @_;
    # pritnableName attribute didnt exists in 2.2.X
    if (not $elements->{printableName}) {
        $elements->{printableName} = $elements->{name}
    }

    return $elements;
}

sub _die
{
    use Devel::StackTrace;
    my $st = Devel::StackTrace->new();
    die $st->as_string();
}

1;
